## l-canonical Representation

This guide is made so that a basic understanding of the l-canonical algorithm can be acquired. It should
help in understanding the implementation and the reasoning behind it (see `varEH.py`).

The l-canonical representation groups natural numbers into differently sized groups determined by the
length of the representation itself `[k_0, k_1, ..., k_n]`. Equivalently, we consider each natural as
the step our algorithm is in (1 item inserted, 2 items inserted, ...). For example, with `l = 2` 
(example from [Twitter's Algebird](https://twitter.github.io/algebird/datatypes/approx/exponential_histogram.html):

            Size of buckets
    Step 1:      1          | Group 0
         2:      2          |
         3:      3          |

         4:      2 1        | Group 1
         5:      3 1        |
         6:      2 2        |
         7:      3 2        |
         8:      2 3        |
         9:      3 3        |

         10:     2 2 1      | Group 2
         11:     3 2 1      |
         12:     2 3 1      |
         13:     3 3 1      |
         14:     2 2 2      |
         15:     3 2 2      |
         ...                ·

So, there is a distinct l-canonical representation for each 'size' of an EH (step). Then, we first need to 
find in what group our natural number S (the size of the new EH) lies into: that is what `j` is for.
It's defined as the biggest `j s.t. 2^j <= (S + l) / (1 + l)`.

Because we know the sizes of each group, we know that S's group size is

    groupSize = (l + 1) * 2^j

So, given this size and `l`, we can extract the natural number in which S's group starts:

    startOfGroup = ((l + 1) * 2^j) - l

Then, we can tell the position of our S in the group (from `0` to `groupSize - 1`). In our code, this position `posInGroup` is
computed from an expression derived from

    posInGroup = S - startOfGroup

But, what's the use? It turns out that the first `n - 1` components of an l-canonical rep. can be computed
from the bits of the little endian rep. of a value given by `posInGroup`:

    modValue = posInGroup mod 2^j

Note that the sequence generated by 'modValue' is recurrent: `[0, 1, 0, 1, 0, 1]` in the case of `j=1`. Then, the y-th (y < n)
component of the l-canonical rep. of S is

    yThComponent = littleEldianBit(modValue, y) + l

That is, the bit in the y-th position of the little eldian representation of `modValue` plus `l`.
The value of the n-th component is finally given by

    nTh = ⌊posInGroup / 2^j⌋ + 1